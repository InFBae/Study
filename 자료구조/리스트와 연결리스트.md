<h3>리스트란</h3>

> 배열은 연관된 데이터를 모아서 관리하기 위해서 사용되는 데이터 타입이다.   
> 변수가 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 저장하기 위한 것이라고 할 수 있다.
>    
> 배열은 인덱스를 통해 접근을 하므로 접근에 대해서는 O(1)의 시간 복잡도를 가진다.   
> 검색에 대해서는 순차검색을 해서 O(n)의 시간 복잡도를 가진다.
> 맨 뒤에 삽입 또는 삭제한다면 O(1)의 시간 복잡도를 가지지만 아닐 때 배열을 복사해서 옮겨줘야 해서 O(n)의 시간 복잡도를 가진다.

<h3>연결리스트란</h3>

> 데이터를 포함하는 노드들을 연결식으로 만든 자료구조이다.
> 노드가 메모리에 연속적으로 배치되지 않고 이전/다음노드의 위치를 확인한다.
>
> 연결리스트는 접근에 대하여 노드들을 순차적으로 지나가야 하므로 O(n)의 시간 복잡도를 가진다.   
> 검색에 대해서는 접근과 마찬가지로 순차적으로 확인해야 해서 O(n)의 시간 복잡도를 가진다.
> 삽입과 삭제에 대하여 연결할 노드에 대해 알고 있다면 O(1)의 시간 복잡도를 가지지만 찾아서 삽입해야 한다면 O(n)의 시간 복잡도를 가진다.   

<h3>배열과 연결리스트의 차이점</h3>

> 배열은 연속된 메모리 구조를 가지지만 연결리스트는 각 노드가 다음 노드에 대한 주소값을 가지고 분리된 메모리를 가지고 있다.   
> 배열은 인덱스로 접근해서 접근이 용이하지만 연결리스트는 노드를 순회해서 찾아야 하므로 접근이 좀 더 오래걸린다.   
> 삽입과 삭제에 대하여 배열은 삽입, 삭제 후 배열의 위치를 조정해주어야 하지만 연결리스트는 주소값만 바꿔주면 돼서 삽입과 삭제에 있어 유리하다.   
> 기계적으로 CPU의 캐시 메모리가 데이터에 접근할 때 연속된 메모리 굉장히 빠른 속도를 보장해서 이 부분에 있어 배열이 유리하다.   


<h4>Array / ArrayList / List의 차이</h4>

> Array는 선언 시 고정된 타입과 크기를 가지고 변경할 수 없다.   
> ArrayList는 고정되지 않은 크기를 가지고 Object 타입을 가져서 원시 자료형을 사용한다면 박싱, 언박싱이 일어난다.
> List는 고정되지 않는 크기를 가지고 고정된 타입을 가져서(컴파일 시 타입추론을 한다) 박싱/언박싱이 일어나지 않는다.

<h4>박싱과 언박싱이란</h4>

> 박싱은 값 형식을 참조 형식으로 변환해 주는 것을 의미하고   
> 언박싱은 박싱했던 값을 다시 원상태로 돌리는 것을 의미한다.   
>
> 값 형식의 타입을 부모형식의 Object 타입으로 변환하면 참조 형식으로 바꾸게 되며 일어나는 것이 박싱, 그 반대의 과정이 언박싱이다.
> Object 타입을 사용하게 되면 어떤 타입이든 다 넣을 수 있지만, 스택에 있는 값 형식을 참조형식으로 바꾸면서 힙에 할당시키게 되고, 언박싱 시 다시 스택으로 가져오면서 힙에 가비지가 쌓이게 된다.
> 그래서 가급적이면 박싱과 언박싱의 사용은 지양해야 한다.  
