<h3>맵 자료구조란</h3>

> Key와 Value로 이루어진 자료구조로 키를 통해 값에 접근할 수 있도록 만들어진 자료 구조다.   
> 키에 대응하는 값을 찾기 위해 키는 중복을 허용하지 않는다.   
> 맵 자료구조의 대표적인 종류로 HashMap, TreeMap, LinkedHashMap이 있는데 C#의 해시맵은 자바의 해시맵과 동일하다.

<h4>해시 테이블이란</h4>

> 키,값을 쌍으로 가지고 키를 해싱을 통해 인덱스로 변환하여 배열에 값을 저장한다.   
> 인덱스로 배열에 접근하기 때문에 삽입, 제거, 탐색이 모두 O(1)로 매우 빠르다.   
> 단점은 저장할 데이터의 양보다 큰 배열이 필요하고 충돌이 발생할 수 있는데 충돌이 많이 발생할 수록 성능에 저하가 생긴다. 

<h4>해시 맵과 해시 테이블의 차이</h4>

> 해시 테이블은 Thread-safe를 지원해 멀티스레드 환경에서도 안정성을 보장하지만 해시 맵은 보장하지 않는다.   
> 해시 테이블은 키에 null을 허용하지 않지만 해시 맵은 허용한다.   
> 해시 테이블은 not fail-fast Enumerarion을 제공해 foreach문을 사용할 수 있지만, 해시 맵은 Enumeration을 제공하지 않는다.   
> 해시 맵은 보조 해시를 사용해 해시 충돌이 덜 발생할 수 있다.   

<h4>해시 셋이란</h4>

> 키, 값의 쌍이 아닌 키만을 저장한다.   
> 키를 해싱함수에 넣어 나온 인덱스에 바로 값을 넣고, 값의 중복을 허용하지 않는다.   
> 보통 중복을 허용하지 않는 값을 저장할 때 사용한다.   

<h4>해시 테이블과 딕셔너리의 차이</h4>

> 딕셔너리는 해시테이블과 동일한 기능을 하지만 내부 저장 방식의 차이가 있다.
> c#에서의 해시테이블은 키와 값 모두 Object 타입으로 저장해, 박싱과 언박싱이 일어난다.
> 반면 딕셔너리는 제네릭 타입을 활용하여 미리 담을 데이터 타입을 지정해 지정한 데이터만 넣을 수 있다. 

<h4>충돌이란</h4>

> 키는 다르지만 해싱함수의 연산결과가 같아 인덱스가 중복될 때 충돌이 발생한다.   
> 충돌을 방지하기 위해 해싱 함수에서 값을 고루 분포되도록 설계해야 한다.   

<h4>충돌 해결법</h4>

> 충돌 해결 방법에는 개방 주소법(Open Addressing 방식과 체이닝(Chaining) 방식이 있다.   
> 개방 주소법은 비어 있는 공간의 인덱스를 찾을 때까지 특정 연산을 통해 인덱스를 재계산하는 방법으로   
> 현재 인덱스로부터 고정된 크기만큼 이동하며 빈 공간을 찾는 Linear Probing 방식   
> Linear Probing과 유사하지만 이동할 때마다 2^0, 2^1, 2^2... 씩 이동하며 빈 공간을 찾는 Quadratic Probing 방식   
> 해시값을 다시 해시 함수에 넣어 새로운 인덱스를 찾는 Double Hashing Probing 방식 등이 있다.   
> 체이닝 방식은 Pair을 링크드 노드 형태로 구현해 기존 값의 뒤에 연결한다.   
> 개방 주소법은 추가적인 메모리를 차지하지 않는 대신 충돌이 많이 발생할 수록 부하가 커진다.   
> 체이닝은 추가적인 연산이 적은 대신 추가로 메모리가 필요하다.

<h4>리사이징</h4>

> 배열(버켓)이 가득 찰 수록 충돌이 많이 발생해 성능이 저하되는데 이름 해결하기 위해 배열을 더 크게 선언해서 값을 옮겨야 한다.   
> 방식에서 All-at-once 방식과 Incremental 방식이 있는데   
> All-at-once 리해싱은 배열의 크기가 변할 때 기존 테이블의 원소를 전부 재해싱하여 새 배열에 넣는 방식으로 테이블이 너무 클 때는 사용이 힘들 수 있다.
> Incremental 리해싱은 일시적으로 배열 두 개를 모두 사용해서 접근할 때 기존 배열의 원소를 새 배열로 옮긴다.
