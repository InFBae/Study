<h3>선택 정렬</h3>

> 데이터의 가장 작은 값 또는 가장 큰 값을 찾아서 앞부터 채운다.   
> 시간복잡도 : 평균 O(n^2) 최악 O(n^2)   
> 공간복잡도 : O(1)


<h3>버블 정렬</h3>

> 서로 인접한 데이터끼리 비교하여 위치를 이동시킨다.   
> 배열의 두번째 위치부터 자신의 앞과 비교하며 바꾼다.   
> 시간복잡도 : 평균 O(n^2) 최악 O(n^2)   
> 공간복잡도 : O(1)   


<h3>삽입 정렬</h3>

> 이미 정렬된 공간에 자신이 들어갈 위치를 찾아 삽입한다.   
> 배열의 두번째 위치부터 시작해 현재 인덱스 -1과 비교해가며 위치를 정한다.   
> 시간복잡도 : 평균 O(n^2) 최악 O(n^2)   
> 공간복잡도 : O(1)   


<h3>힙 정렬</h3>

> 반정렬상태를 갖고 있는 힙을 이용하여 데이터를 힙에 넣어 정렬한다.   
> 힙에 넣었다가 하나씩 빼면서 배열에 넣는다.   
> nlogn의 시간 복잡도를 보장하지만 메모리 지역성 때문에 비교적 느린 속도를 가진다.   
> 시간복잡도 : 평균 O(nlogn) 최악 O(nlogn)
> 공간복잡도 : O(1)


<h3>병합 정렬</h3>

> 분할 정복 방식으로 설계된 알고리즘으로 배열의 크기가 1보다 작거나 같을 때까지 나누고 합치면서 정렬을 수행한다.   
> 분할 후 합칠 때 순서에 맞게 배열에서 값을 빼서 정렬한다.   
> 최악의 경우에도 nlogn의 시간 복잡도를 보장하지만 추가적인 메모리를 필요로한다.    
> 시간복잡도 : 평균 O(nlogn) 최악 O(nlogn)   
> 공간복잡도 : O(n)


<h3>퀵 정렬</h3>

> 퀵 정렬 또한 분할정복의 방식을 사용하지만 피벗이라는 기준으로 두고 값을 나눈다.   
> 분할과 동시에 정렬을 진행하며 더 이상 배열을 나눌 수 없을 때까지 분할하고 정렬한다.   
> 평균적으로 가장 빠른 정렬속도를 가지지만 피벗의 설정이 편향될 경우 n^2의 시간 복잡도를 가지게 될 수 있다.    
> 시간복잡도 : 평균 O(nlogn) 최악 O(n^2)   
> 공간복잡도 : O(1)   


<h3>안정정렬과 불안정정렬</h3>

> 

<h3>C#의 정렬</h3>

> 인트로 정렬


